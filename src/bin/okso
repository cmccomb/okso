#!/usr/bin/env bash
# shellcheck disable=SC2034
#
# Entrypoint for the local assistant harness.
#
# Usage:
#   ./src/bin/okso [OPTIONS] -- "user query"
#
# Options:
#   -h, --help            Show help text.
#   -V, --version         Show version information.
#   -y, --yes, --no-confirm
#                         Approve all tool runs without prompting.
#   -v, --verbose LEVEL   Set log verbosity level (integer, e.g., -v 1, -v 2).
#   -q, --quiet           Silence informational logs.
#
# Environment:
#   LLAMA_BIN       llama.cpp binary (default: llama-completion).
#
# Dependencies:
#   - bash 3.2+
#   - Optional: llama.cpp binary available on PATH for real scoring.
#
# Exit codes:
#   0 on success, non-zero on argument or runtime errors.

set -euo pipefail

resolve_script_dir() {
	local source_path source_dir
	source_path="${BASH_SOURCE[0]}"

	while [ -h "${source_path}" ]; do
		source_dir=$(cd -P -- "$(dirname -- "${source_path}")" && pwd)
		source_path=$(readlink "${source_path}")
		if [[ "${source_path}" != /* ]]; then
			source_path="${source_dir}/${source_path}"
		fi
	done

	cd -P -- "$(dirname -- "${source_path}")" && pwd
}

SCRIPT_DIR=$(resolve_script_dir)
SRC_ROOT=$(cd "${SCRIPT_DIR}/.." && pwd)
LIB_DIR="${SRC_ROOT}/lib"
export OKSO_ENTRYPOINT="${OKSO_ENTRYPOINT:-./src/bin/okso}"

# shellcheck source=src/lib/core/errors.sh
source "${LIB_DIR}/core/errors.sh"
# shellcheck source=src/lib/core/logging.sh
source "${LIB_DIR}/core/logging.sh"
# shellcheck source=src/lib/core/json_state.sh
source "${LIB_DIR}/core/json_state.sh"
# shellcheck source=src/lib/config.sh
source "${LIB_DIR}/config.sh"
# shellcheck source=src/lib/tools.sh
source "${LIB_DIR}/tools.sh"
# shellcheck source=src/lib/planning/planner.sh
source "${LIB_DIR}/planning/planner.sh"
# shellcheck source=src/lib/cli/cli.sh
source "${LIB_DIR}/cli/cli.sh"
# shellcheck source=src/lib/runtime.sh
source "${LIB_DIR}/runtime.sh"

main() {
	local settings_prefix
	local plan_outline required_tools plan_entries plan_action plan_response

	settings_prefix="settings"

	load_runtime_settings "${settings_prefix}" "$@"

	if [[ "$(json_state_get_key "${settings_prefix}" "command")" == "init" ]]; then
		# Init mode writes a config file and exits without running the planner.
		apply_settings_to_globals "${settings_prefix}"
		write_config_file
		return 0
	fi

	prepare_environment_with_settings "${settings_prefix}"

	initialize_planner_models
	# Planner flow:
	# 1. Generate an outline, 2. identify tools, 3. build concrete plan entries
	# for execution, then 4. render plan outputs before proceeding.
	log "INFO" "Starting plan generation" "$(json_state_get_key "${settings_prefix}" "user_query")"
	plan_response="$(generate_planner_response "$(json_state_get_key "${settings_prefix}" "user_query")")"
	plan_outline="$(plan_json_to_outline "${plan_response}")"
	required_tools="$(derive_allowed_tools_from_plan "${plan_response}")"
	log "INFO" "Planner identified tools" "${required_tools}"
	plan_entries="$(plan_json_to_entries "${plan_response}")"

	render_plan_outputs plan_action "${settings_prefix}" "${required_tools}" "${plan_entries}" "${plan_outline}" "${plan_response}"
	if [[ "${plan_action}" == "exit" ]]; then
		return 0
	fi

	select_response_strategy "${settings_prefix}" "${required_tools}" "${plan_entries}" "${plan_outline}" "${plan_response}"
}

main "$@"
